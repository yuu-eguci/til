#!bin/sh
# シェルスクリプトメモ

# ==============================
# bash書くときの注意
#     改行コマンドはLF(unix)にすること
# ==============================

# ==============================
# 空白入り文字列 grep if
# ==============================
# 以下は失敗する
a="aaa a b"
if [ `echo $a | grep a b` ] ; then
    echo "OK!!"
fi
# こうすりゃいい
a="aaa a b"
echo $a | grep 'a b' > /dev/null
if [ $? -eq 0 ] ; then
    echo 'OK!'
else
    echo 'NG!'
fi

# ==============================
# ↑の関数化
# ==============================
str_find() {
    # ==============================
    # $1:haystack $2:needle $return:1(found)or0(not found)
    # ==============================
    echo $1 | grep $2 > /dev/null
    echo $?
}
str_find 'aaa aaa' 'a'
str_find 'aaa aaa' 'b'
if [ $(str_find 'aaa aaa' 'a') -eq 0 ] ; then
    echo "ok"
else
    echo "ng"
fi
if [ $(str_find 'aaa aaa' 'b') -eq 0 ] ; then
    echo "ok"
else
    echo "ng"
fi

# ==============================
# awk $1とか$2はカラム単位じゃなくてスペース分割単位
# この例では、1単位目が数字ではじまるものを抽出する
# ==============================
vim-cmd vmsvc/getallvms | awk '{ print $1 }' | grep '^[0-9]'

# ==============================
# ふたつ以上の条件を使ってgrep for grep結果の要素数
# ==============================
a=$(vim-cmd vmsvc/getallvms | grep '^[0-9]' | grep '\[datastore1\]' | awk '{ print $1 }')
echo $a
for var in $a
do
    echo $var
done
b=$(vim-cmd vmsvc/getallvms | grep '^[0-9]' | grep -c '\[datastore1\]')
echo $b

# ==============================
# 正規表現をつかったgrep抜き出し、sed置換
# ==============================
# 37 vSphere Management Assistant (v [datastore1] ... から vSphere Management Assistant (v を抜き出す
# grep -o : " [0-9a-zA-z].*\[" の部分を抽出
# sed -e s : ' *\[' を '' に置換する
vim-cmd vmsvc/getallvms | grep '^37' | grep -o " [0-9a-zA-z].*\[" | sed -e s/' *\['/''/

# ==============================
# 関数の返り値はこうやって作ればいいかもしれない
# ==============================
foo() {
    # 標準エラー出力
    echo "0" 1>&2
    echo "0" 2>&1
}
[ $(foo) -eq '0' ] && echo 'OK' || echo 'FAIL'

# ==============================
# 返り値の作り方その2 returnは終了ステータスを返す
# ==============================
bar() {
    if [ "$1" = '0' ] ; then
        return '0'
    elif [ "$1" = '1' ] ; then
        return '1'
    else
        return '2'
    fi
}
bar 1
echo $?    # ここに終了ステータスが出るんで、これを返り値として利用できる

# ==============================
# シェルスク内からほかのシェルスクを実行する . と source は一緒っぽい?
# ==============================
/ba2.sh        # ba2は実行されるが、ba2内の変数は使えない 実行されるだけ
. /ba2.sh      # ba2が実行され、ba2の変数も使えるようになる
source /ba2.sh # ba2が実行され、ba2の変数も使えるようになる
# 仕組み
#     . or source は指定したスクリプトを現在と同じスクリプトで実行する
#     普段シェルスクを呼び出すときは、シェル内で新しいシェルが立ち上がっているため、
#     sh内で cd しても終了したら戻ってきてしまうのだ。

# ==============================
# 関数のデフォルト値
# ==============================
foo() {
    echo ${1:-'a'}    # $1が空白のときaと出る
    echo ${2:+'b'}    # $2が空白じゃないときbと出る  何に使うんだコレ…
}

# ==============================
# 変数の存在確認  undefined variableがエラーにならないシェルならではのおもしろ手法
# ==============================
if [ -z "${variable+a}" ] ; then
    echo '$variableはない'
fi
# -z は文字列の長さが0なら真になる
# ${variable+a} はなんかよくわからないんだけど、variableが未定義なら空欄、定義済みならaになる  どういうことなんだろね

# ==============================
# if文における '=' と '-eq' の違い
# 右辺が数値のときはどっちでもいい  右辺が文字列のときは=を使わないとbad numberエラーが出る
# ==============================
if   [ "$a" -eq '1' ] ; then
    echo "ok"
elif [ "$b" = ',' ] ; then
    echo "ok"
fi

# ==============================
# sendmailのつかいかた
# ==============================
sendmail
    -t    # メールアドレスとかをメール本文中のヘッダから取得
    -f    # fromアドレスの指定
    -F    # fromのコメント文字列
    -i    # メール本文中の、'.'のみの行を本文の終了とみなさない
    --    # 宛先メールアドレス










