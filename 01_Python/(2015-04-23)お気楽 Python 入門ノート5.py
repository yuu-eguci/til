# http://www.geocities.jp/m_hiroi/light/index.html#python_abc
# ここの情報ノート

# --- object ---
	# 普通プログラムの部品は関数だが、オブジェクト指向プログラミングではオブジェクトを部品として扱う
	# オブジェクトはデータと関数をひとつにまとめたもの
	# 鉛筆の色・長さ・固さがデータで、それを入力して書いたり描いたりするのが関数
	# オブジェクトはそれが一緒になってるので、赤鉛筆2Bオブジェクトに書けといえば赤で書いてくれる。

	# よくわからん。たぶんオブジェクト指向プログラミングしか知らないからだろう

# --- class, instance, method ---
	# クラスは設計図。それをもとに作り出される実体がインスタンス。インスタンスがオブジェクト。
	# クラス内の変数がインスタンス変数で、オブジェクトを操作する関数がメソッド
	# クラスという設計図が中心にあり、そこからインスタンスが生み出され、メソッドを使ってインスタンスを操作する、という関係

# --- polymorphism ---
	# クラスが違えば、同じ名前のメソッドを定義できる
	# class Foo1 にメソッド bar() があっても、 class Foo2 に同名の bar() を定義してもいい
	# bar() を呼び出したとき、それが Foo1 のオブジェクトだったら Foo1 で定義した bar() が実行される
	# この機能がポリモーフィズム。

# --- class 文 ---
	class class_name(super_class, ...):
	# class 文の構文。カッコをつけると中のクラスの機能を継承できる。継承は後述
	class Foo:
		pass # 何もしないの意
	# 普通クラス名は大文字で始める。これを実行すると
	>>> a = Foo()
	>>> a
	< __main__.Foo instance at ...>
	# クラスのインスタンスを生成して返す。引数も指定できるが後述
	# インスタンス変数へのアクセスは
	>>>a.x # こんなふうにやる。ただしインスタンス内に x は存在しないのでエラーが出る
	>>> a.x = 10 # こうするとインスタンス変数 x を生成して、そこに10を代入してくれる
	>>> a.x
	10

# --- method ---
	# 関数と同じく def 文で定義。 class 文のなかで定義された関数がメソッド
	# メソッドの第一引数にはインスタンスが渡される。この引数名は self と記述する習慣がある
	# 点を表わし、二点間の距離を求めるクラス(x, y 座標をインスタンス変数 x, y に格納)
	class Point:
		def __init__(self, x1, y1):
		# 特殊メソッド __init__() はインスタンス生成時自動で呼び出される
		# ここで必要なインスタンス変数を初期化
		# あーアレか、普通に関数かくとき最初に使う変数を number = 0 とかやるようなもんか。
		# self には Point のインスタンスが渡される
			self.x = x1
			self.y = y1 # self(インスタンス)の中にインスタンス変数 x, y を作って値をセット
		def distance(p1, p2):
			dx = p1.x - p2.x
			dy = p1.y - p2.y
			return math.sqrt(dx * dx + dy * dy) # モジュール math の関数 sqrt() は平方根を求める
	# 試す
	>>> a = Point(0, 0)
	# __init__() の第一引数はインスタンスの席なので、(0, 0)で x = y = 0 になる
	>>> a.x
	0
	# メソッド distance() は Point クラスのインスタンスを二つ受け取り距離を計算する
	# 呼び出し方はこう
	>>> a = Point(0, 0)
	>>> b = Point(10, 10)
	>>> a.distance(b)
	14.142....
	# Python はまず a が属するクラスを調べる。 a　には Point のインスタンスが格納されてるので、
	# Point に定義されてるメソッドを調べ、 distance() を呼び出す
	# こう書いてもいい
	>>> Point.distance(a, b)
	# こっちのが分かりやすいじゃねーか。
	# 3次元の座標を表す Point3D クラス
	class Point3D:
		def __init__(self, x1, y1, z1):
			self.x = x1
			self.y = y1
			self.z = z1
		def distance(p1, p2):
			dx = p1.x - p2.x
			dy = p1.y - p2.y
			dz = p1.z - p2.z
			return math.sqrt(dx * dx + dy * dy + dz * dz)
	>>> a = Point(0, 0)
	>>> b = Point(10, 10)
	>>> c = Point3D(0, 0, 0)
	>>> d = Point3D(10, 10, 10) # a, b, c, d の4つのインスタンスが生成
	>>> a.distance(b) # インスタンスがどの設計図をもとに作られたか参照する
	14.142...
	>>> c.distance(d)
	17.320...
	# ドットの左側のインスタンスによって適切なメソッドが呼び出される = ポリモーフィズム
	# インスタンスの種別を調べるには関数 isinstance() を使う
	isinstance(object, class_name)

# --- クラス変数 ---
	# インスタンス変数は個々のインスタンスに格納される変数で、
	# クラスで共通の変数はクラス変数という
	class Foo:
		z = 1
	>>> Foo.z # 1
	a = Foo() # インスタンス a の生成 (実際はインスタンスを生成して変数 a にセットしてるのだが)
	b = Foo() # 同じく b の生成
	>>> a.z # 1
	>>> b.z # 1
	Foo.z = 10 
	>>> a.z # 10
	>>> b.z # 10
	# 変数 z は class Foo 内で定義してるからクラス変数
	# クラス変数は クラス名.変数名 でアクセス可能

# --- インスタンスメソッド、クラスメソッド ---
	# インスタンスを操作するメソッド = インスタンスメソッド
	# クラスの動作にかかわるメソッド = クラスメソッド
	# class Foo のクラス変数 z を操作するクラスメソッド get_z() set_z() を考えてみる
	class Foo:
		z = 0
		def get_z(cls):
			return cls.z
		get_z = classmethod(get_z)
		def set_z(cls, x):
			cls.z = x
		set_z = classmethod(set_z)
	>>> Foo.get_z() # 0
	>>> Foo.set_z(10)
	>>> Foo.get_z() # 10
	>>> a = Foo()
	>>> a.get_z() # 10


